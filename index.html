<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Music Visualizer Ripple</title>
  <style>
    /* Basic Page Styles */
    body {
      margin: 0;
      padding: 0;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #fff;
      font-family: Arial, sans-serif;
    }
    #fileInput {
      margin: 20px;
    }
    /* Fullscreen Canvas */
    canvas {
      border: 1px solid #222;
      display: block;
    }
  </style>
</head>
<body>
  <input type="file" id="fileInput" accept="audio/mp3">
  <canvas id="canvas"></canvas>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const fileInput = document.getElementById('fileInput');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // Set canvas size to fill the window.
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      let audioContext, analyser, source, audio;
      let dataArray, bufferLength;
      const ripples = [];
      let lastRippleTime = 0;
      const minRippleInterval = 200; // Minimum ms between new ripples

      fileInput.addEventListener('change', function() {
        const file = this.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);

        // Create an HTML Audio element to play the file.
        audio = new Audio(url);
        audio.crossOrigin = "anonymous";
        audio.loop = true;
        audio.play();

        // Set up the Web Audio API.
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);

        source = audioContext.createMediaElementSource(audio);
        source.connect(analyser);
        analyser.connect(audioContext.destination);

        animate();
      });

      // Animation function that continuously draws on the canvas.
      function animate() {
        requestAnimationFrame(animate);
        analyser.getByteFrequencyData(dataArray);

        // Calculate an average volume level from frequency data.
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        const average = sum / dataArray.length;

        // If the average amplitude exceeds a threshold and enough time has passed,
        // create a new ripple at the center of the canvas.
        const threshold = 150;
        const currentTime = performance.now();
        if (average > threshold && currentTime - lastRippleTime > minRippleInterval) {
          lastRippleTime = currentTime;
          ripples.push({
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 0,
            alpha: 1
          });
        }

        // Clear the canvas with a semi-transparent black rectangle for trailing effect.
        ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Update and draw each ripple.
        for (let i = 0; i < ripples.length; i++) {
          const ripple = ripples[i];
          // Increase the radius and decrease the transparency.
          ripple.radius += 3;
          ripple.alpha -= 0.01;
          if (ripple.alpha <= 0) {
            ripples.splice(i, 1);
            i--;
            continue;
          }
          // Draw the ripple with a stroke whose hue cycles based on its radius.
          ctx.beginPath();
          ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
          const hue = Math.floor(ripple.radius % 360);
          ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${ripple.alpha})`;
          ctx.lineWidth = 4;
          ctx.stroke();
        }
      }
    });
  </script>
</body>
</html>
